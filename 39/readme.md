# 39. 组合总和
这道题我一开始一直想用动态规划的方式去做，最后反而成了障碍。这道题直接遍历会好很多。

这道题的 trick 主要就是遍历的时候如何防止 [2,3,2] [2,2,3] 这种本来应该算作一种的分解方式算作两种，比较简单的方法就是每次选择 candidate 的时候都选择大于 path 最后一个元素的 candidate。

39.py 还有一个 trick 就是再传入 list 的时候，传入的是刚刚生成的 list（第 15 行），这样内层 path 的变化就不会影响到外层的 path，省去了先 append 再 pop。

## 为什么这道题不适合动态规划
动态规划就是记录嘛~ 所以查一次表就要获得多于“一步”的信息，否则和遍历没什么区别。

39-isOrNot.py 就是基于动态规划做的，但是只能判断一个数是否可以用给定的数字组合出来。

39-isOrNot.py 中的 `calcul` 就是用于记录的表，但是表的 key 代表需要被分解的数，val 表示可以怎么分解，比如：

```python
{
    8:[
        [2,6],
        [3,5],
        [5,3]
        ]
}
```
表示 8 可以被分成 2,6 3,5 5,3，但是 6 怎么分就需要继续查表。

这就犯了大忌，查一次表只可以得到一步的信息，和遍历没有差别。

你可能会问，为什么不用表中 6 的组合取代 8:[2,6] 中的 6 呢。问得好，首先 6 有不止一种分法，其次所有的分法都需要到最后一步才能知道是否可行，如果此时再依次更改被分解数对应的列表（8,6...），就做了很多没什么用的工作，时间复杂度就上去了。

总之，动态规划不适合这个题目。
