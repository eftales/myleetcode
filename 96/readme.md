# 96
这道题一开始我是没有思路的，但是隐隐约约感觉可以用 dp 来做。再加上昨天刚刚做了 120 的 dp，所以就往这个方面想了想。

## dp

1. 弄清楚最后一步，看除了最后一步之外，剩下的是不是一个子问题。

    讲道理这个题目的最后一步不太明确，但是我认为可以拆成子问题。需要组成树的元素值是连续的，选择一个节点作为根节点之后，所有小于根节点的元素都在根节点的左子树上，所有大于根节点的元素都在根节点的右子树上。

    接着我尝试画了一下 n=2,3,4 的情况，有了新的发现。n=3 的左右子树分别是 n=2 和 n=1 情况下的变形，n=4 同理。因此有了状态转移方程：

    *`f(n) = f(n-1)*f(0) + f(n-2)*f(1) + ... + f(n-k)*f(k-1) + ... + f(0)*f(n-1)`*

2. 数组 f 已经弄好了，f(n) 表示 1,2,...,n 有 f(n) 种二叉搜索树。

3. 边界也很简单，当 f(n)=1,f(1)=1

4. 从 n=2 开始算，也算时一个自顶向下吧


## 卡塔兰公式
做完之后看答案才发现 dp 里面那个递推公式是卡塔兰公式的一种变种。。。

$ C_{n}^{m} $ 是组合数。

$$ Catalan_{n+1} = \frac {2(2n+1)}{n+2} Catalan_n = C_{2n}^n - C_{2n}^{n-1} $$ 

$$ <==> $$

$$ f(n) = f(n-1)*f(0) + f(n-2)*f(1) + ... + f(n-k)*f(k-1) + ... + f(0)*f(n-1) $$

*`C = 2 * (2*i +1)*C/(i+2)`*

算法复杂度瞬间从 O(n*n) 降低到 O(n)...

瞬间感觉到数学还是大爷。

卡塔兰公式的更多内容看[这篇](https://baike.baidu.com/item/catalan/7605685?fr=aladdin)。



# tips
二叉搜索树：对于所有的根节点来说，左子树上的所有元素都比自己大，右子树上的所有元素都比自己小。

通过先序遍历就可以得到排序过后的数组。

先序遍历算法的步骤：

1. 如果有左子树就进入左子树，直到没有左子树，执行 2；
2. 读取自己的值，执行 3；
3. 进入右子树，执行 1。
