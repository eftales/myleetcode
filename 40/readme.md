# 40. 组合总和 II
这个题最难的地方还是去重，升序序列已经不能保证不重复了。

[1,1,1,7] -> 8

既可以是 第一个 1 和 7，还可以是第二个 1 和 7 等等。

40.py 中最精髓的是第 27 行，在每一层的遍历中拒绝访问相同的元素，保证了不会出现两个 1,7。因为数值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果!

## 距离说明第 27 行是如何运行的
以 [1,1,1,7] -> 8 为例：

1. 第一次递归：

    i = 0，target - candidates[i] = 7，开始递归

2. 第二次递归

    i = 1，target - candidates[i] = 6，开始递归

3. 第三次递归

    i = 2，target - candidates[i] = -1，return 到第二次递归

4. 第二次递归

    i = 2，i = 1 时所有的运算结果没有被保存下来，target - candidates[i] = 6，开始递归，本次递归和 i = 1 的那次递归很相似，都是选择了两个 1

5. 第四次递归

    i = 3，target - candidates[i] = -1，return 到第二次递归

6. 第二次递归

    i = 3，target - candidates[i] = 0，保存结果，return 到第一次递归

7. 第一次递归

    i = 1，满足 `i>0 and candidates[i] == candidates[i-1] and begin<i` 所以直接跳过。

    不允许在一层递归中选中相同的元素，否则可能会造成重复答案。
